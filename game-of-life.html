<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Game Of Life</title>
</head>

<body onload="start()">
  <div>
    <h3>Conway's Game of Life</h3>
    <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Wikipedia Reference</a>
  </div>
  <br>
  <div id="stats">
    <div>Generations: <span id="generationCount"></span></div>
    <div id="gameOver"></div>
  </div>
  <canvas id="canvas"></canvas>
</body>

<script>
  // constants
  const LIFE = 1;
  const DEATH = 0;
</script>

<script>
  // only pure util functions
  function zeros(numRows, numCols) {
    return Array(numRows).fill(0).map(rv => Array(numCols).fill(0).map(cv => 0));
  }

  function gridClone(grid) {
    const clone = zeros(grid.length, grid[0].length);
    for (let r = 0; r < grid.length; r++) {
      for (let c = 0; c < grid[0].length; c++) {
        clone[r][c] = grid[r][c];
      }
    }
    return clone;
  }

  function randomized(grid, randomLifeThreshold) {
    for (let r = 0; r < grid.length; r++) {
      for (let c = 0; c < grid[0].length; c++) {
        grid[r][c] = Math.random() >= randomLifeThreshold ? LIFE : DEATH;
      }
    }
  }

  function seedRandom(numRows, numCols, randomLifeThreshold) {
    const grid = zeros(numRows, numCols);
    randomized(grid, randomLifeThreshold);
    return grid;
  }

  function seedOscillatorBlinker(numRows, numCols) {
    const grid = zeros(numRows, numCols);
    let r0 = Math.floor(numRows / 2);
    let c0 = Math.floor(numCols / 2);

    grid[Math.max(0, r0 - 1)][Math.max(1, c0)] = 1;
    grid[Math.max(0, r0)][c0] = 1;
    grid[Math.max(0, r0 + 1)][c0] = 1;
    return grid;
  }

  function seedOscillatorToad(numRows, numCols) {
    const grid = zeros(numRows, numCols);
    let r0 = Math.floor(numRows / 2);
    let c0 = Math.floor(numCols / 2);

    grid[Math.max(0, r0 - 1)][Math.max(1, c0)] = 1;
    grid[Math.max(0, r0)][c0] = 1;
    grid[Math.max(0, r0 + 1)][c0] = 1;
    return grid;
  }

  function seed(config) {// the global CONFIG
    return seedRandom(config.numRows, config.numCols, config.randomLifeThreshold);
  }

  function lifeOrDeath(r, c, grid) {
    // Any live cell with two or three live neighbours survives.
    // Any dead cell with three live neighbours becomes a live cell.
    // All other live cells die in the next generation. Similarly, all other dead cells stay dead.
    let liveNeighbours = 0;

    liveNeighbours += (r - 1 >= 0 && grid[r - 1][c] == LIFE) ? 1 : 0;
    liveNeighbours += (r + 1 < grid.length && grid[r + 1][c] == LIFE) ? 1 : 0;
    liveNeighbours += (c - 1 >= 0 && grid[r][c - 1] == LIFE) ? 1 : 0;
    liveNeighbours += (c + 1 < grid[0].length && grid[r][c + 1] == LIFE) ? 1 : 0;

    liveNeighbours += (r - 1 >= 0 && c - 1 >= 0 && grid[r - 1][c - 1] == LIFE) ? 1 : 0;
    liveNeighbours += (r - 1 >= 0 && c + 1 < grid[0].length && grid[r - 1][c + 1] == LIFE) ? 1 : 0;
    liveNeighbours += (r + 1 < grid.length && c - 1 >= 0 && grid[r + 1][c - 1] == LIFE) ? 1 : 0;
    liveNeighbours += (r + 1 < grid.length && c + 1 < grid[0].length && grid[r + 1][c + 1] == LIFE) ? 1 : 0;

    if (grid[r][c] == LIFE && (liveNeighbours == 2 || liveNeighbours == 3)) {
      return LIFE;
    }
    if (grid[r][c] == DEATH && liveNeighbours == 3) {
      return LIFE;
    }
    return DEATH;
  }

  function nextGeneration(grid) {
    const oldGen = gridClone(grid);
    let hasLife = false;
    // in-place update grid as next generation
    for (let r = 0; r < grid.length; r++) {
      for (let c = 0; c < grid[0].length; c++) {
        grid[r][c] = lifeOrDeath(r, c, oldGen);

        if (grid[r][c] == LIFE) {
          hasLife = true;
        }
      }
    }
    return hasLife;
  }

</script>

<script>
  function setupCanvas(config) {
    canvas = document.getElementById("canvas");
    canvas.width = config.canvasWidth;
    canvas.height = config.canvasHeight;
    canvas.style.border = "1px solid #000";
    return canvas;
  }

  function drawGridToCanvas(canvasElem, config, grid) {
    const context = canvasElem.getContext("2d");

    context.clearRect(0, 0, canvasElem.width, canvasElem.height);

    // Workaround to avoid blurry rectangle border
    context.strokeRect1 = function (x, y, w, h) {
      x = parseInt(x) + 0.50;
      y = parseInt(y) + 0.50;
      this.strokeRect(x, y, w, h);
    }
    context.fillRect1 = function (x, y, w, h) {
      x = parseInt(x);
      y = parseInt(y);
      context.fillRect(x, y, w, h);
    }

    context.strokeStyle = config.cellBorderStyle;
    context.fillStyle = config.cellFillStyle;

    // draw grid
    for (let r = 0; r < grid.length; r++) {
      for (let c = 0; c < grid[0].length; c++) {
        let x = config.cellWidth * c;
        let y = config.cellHeight * r;
        if (grid[r][c] == LIFE) {
          // life, fill it
          context.fillRect1(x, y, config.cellWidth, config.cellHeight);
        }
        context.strokeRect1(x, y, config.cellWidth, config.cellHeight);
      }
    }
  }

  function updateStats(generationCount) {
    const generationCountElem = document.getElementById("generationCount");
    if (generationCountElem) {
      generationCountElem.innerText = generationCount;
    }
  }

  function showGameOver() {
    const gameOverElem = document.getElementById("gameOver");
    if (gameOverElem) {
      gameOverElem.innerText = "Game Over!";
    }
  }

  function start() {
    console.log("Start...");

    const CONFIG = {
      canvasWidth: 800,
      canvasHeight: 800,
      numRows: 100,
      numCols: 100,
      randomLifeThreshold: 0.7,
      cellBorderStyle: "#ccc",
      cellFillStyle: "#066", // LIFE cell fill color
      lifeSpanMilliSeconds: 1000,
    }

    CONFIG.cellWidth = Math.floor(CONFIG.canvasWidth / CONFIG.numCols);
    CONFIG.cellHeight = Math.floor(CONFIG.canvasHeight / CONFIG.numRows);

    console.log("CONFIG: ", CONFIG);

    const GRID = seed(CONFIG);
    console.log("First Generation: ", GRID);

    const canvas = setupCanvas(CONFIG);

    let generationCount = 0;
    drawGridToCanvas(canvas, CONFIG, GRID);
    updateStats(generationCount);

    let interval = setInterval(() => {
      const hasLife = nextGeneration(GRID);
      updateStats(++generationCount);

      drawGridToCanvas(canvas, CONFIG, GRID);
      if (!hasLife) {
        clearInterval(interval);
        showGameOver();
      }
    }, CONFIG.lifeSpanMilliSeconds);
  }
</script>

</html>
